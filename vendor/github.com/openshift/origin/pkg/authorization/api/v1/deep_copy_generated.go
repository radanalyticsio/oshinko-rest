// +build !ignore_autogenerated_openshift

// This file was autogenerated by deepcopy-gen. Do not edit it manually!

package v1

import (
	api "k8s.io/kubernetes/pkg/api"
	unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	api_v1 "k8s.io/kubernetes/pkg/api/v1"
	conversion "k8s.io/kubernetes/pkg/conversion"
	runtime "k8s.io/kubernetes/pkg/runtime"
)

func init() {
	if err := api.Scheme.AddGeneratedDeepCopyFuncs(
		DeepCopy_v1_Action,
		DeepCopy_v1_ClusterPolicy,
		DeepCopy_v1_ClusterPolicyBinding,
		DeepCopy_v1_ClusterPolicyBindingList,
		DeepCopy_v1_ClusterPolicyList,
		DeepCopy_v1_ClusterRole,
		DeepCopy_v1_ClusterRoleBinding,
		DeepCopy_v1_ClusterRoleBindingList,
		DeepCopy_v1_ClusterRoleList,
		DeepCopy_v1_IsPersonalSubjectAccessReview,
		DeepCopy_v1_LocalResourceAccessReview,
		DeepCopy_v1_LocalSubjectAccessReview,
		DeepCopy_v1_NamedClusterRole,
		DeepCopy_v1_NamedClusterRoleBinding,
		DeepCopy_v1_NamedRole,
		DeepCopy_v1_NamedRoleBinding,
		DeepCopy_v1_Policy,
		DeepCopy_v1_PolicyBinding,
		DeepCopy_v1_PolicyBindingList,
		DeepCopy_v1_PolicyList,
		DeepCopy_v1_PolicyRule,
		DeepCopy_v1_ResourceAccessReview,
		DeepCopy_v1_ResourceAccessReviewResponse,
		DeepCopy_v1_Role,
		DeepCopy_v1_RoleBinding,
		DeepCopy_v1_RoleBindingList,
		DeepCopy_v1_RoleList,
		DeepCopy_v1_SelfSubjectRulesReview,
		DeepCopy_v1_SelfSubjectRulesReviewSpec,
		DeepCopy_v1_SubjectAccessReview,
		DeepCopy_v1_SubjectAccessReviewResponse,
		DeepCopy_v1_SubjectRulesReviewStatus,
	); err != nil {
		// if one of the deep copy functions is malformed, detect it immediately.
		panic(err)
	}
}

func DeepCopy_v1_Action(in Action, out *Action, c *conversion.Cloner) error {
	out.Namespace = in.Namespace
	out.Verb = in.Verb
	out.Group = in.Group
	out.Version = in.Version
	out.Resource = in.Resource
	out.ResourceName = in.ResourceName
	if err := runtime.DeepCopy_runtime_RawExtension(in.Content, &out.Content, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_ClusterPolicy(in ClusterPolicy, out *ClusterPolicy, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_Time(in.LastModified, &out.LastModified, c); err != nil {
		return err
	}
	if in.Roles != nil {
		in, out := in.Roles, &out.Roles
		*out = make(NamedClusterRoles, len(in))
		for i := range in {
			if err := DeepCopy_v1_NamedClusterRole(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Roles = nil
	}
	return nil
}

func DeepCopy_v1_ClusterPolicyBinding(in ClusterPolicyBinding, out *ClusterPolicyBinding, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_Time(in.LastModified, &out.LastModified, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectReference(in.PolicyRef, &out.PolicyRef, c); err != nil {
		return err
	}
	if in.RoleBindings != nil {
		in, out := in.RoleBindings, &out.RoleBindings
		*out = make(NamedClusterRoleBindings, len(in))
		for i := range in {
			if err := DeepCopy_v1_NamedClusterRoleBinding(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.RoleBindings = nil
	}
	return nil
}

func DeepCopy_v1_ClusterPolicyBindingList(in ClusterPolicyBindingList, out *ClusterPolicyBindingList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]ClusterPolicyBinding, len(in))
		for i := range in {
			if err := DeepCopy_v1_ClusterPolicyBinding(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_ClusterPolicyList(in ClusterPolicyList, out *ClusterPolicyList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]ClusterPolicy, len(in))
		for i := range in {
			if err := DeepCopy_v1_ClusterPolicy(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_ClusterRole(in ClusterRole, out *ClusterRole, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if in.Rules != nil {
		in, out := in.Rules, &out.Rules
		*out = make([]PolicyRule, len(in))
		for i := range in {
			if err := DeepCopy_v1_PolicyRule(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Rules = nil
	}
	return nil
}

func DeepCopy_v1_ClusterRoleBinding(in ClusterRoleBinding, out *ClusterRoleBinding, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if in.UserNames != nil {
		in, out := in.UserNames, &out.UserNames
		*out = make(OptionalNames, len(in))
		copy(*out, in)
	} else {
		out.UserNames = nil
	}
	if in.GroupNames != nil {
		in, out := in.GroupNames, &out.GroupNames
		*out = make(OptionalNames, len(in))
		copy(*out, in)
	} else {
		out.GroupNames = nil
	}
	if in.Subjects != nil {
		in, out := in.Subjects, &out.Subjects
		*out = make([]api_v1.ObjectReference, len(in))
		for i := range in {
			if err := api_v1.DeepCopy_v1_ObjectReference(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Subjects = nil
	}
	if err := api_v1.DeepCopy_v1_ObjectReference(in.RoleRef, &out.RoleRef, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_ClusterRoleBindingList(in ClusterRoleBindingList, out *ClusterRoleBindingList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]ClusterRoleBinding, len(in))
		for i := range in {
			if err := DeepCopy_v1_ClusterRoleBinding(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_ClusterRoleList(in ClusterRoleList, out *ClusterRoleList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]ClusterRole, len(in))
		for i := range in {
			if err := DeepCopy_v1_ClusterRole(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_IsPersonalSubjectAccessReview(in IsPersonalSubjectAccessReview, out *IsPersonalSubjectAccessReview, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_LocalResourceAccessReview(in LocalResourceAccessReview, out *LocalResourceAccessReview, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1_Action(in.Action, &out.Action, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_LocalSubjectAccessReview(in LocalSubjectAccessReview, out *LocalSubjectAccessReview, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1_Action(in.Action, &out.Action, c); err != nil {
		return err
	}
	out.User = in.User
	if in.GroupsSlice != nil {
		in, out := in.GroupsSlice, &out.GroupsSlice
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.GroupsSlice = nil
	}
	if in.Scopes != nil {
		in, out := in.Scopes, &out.Scopes
		*out = make(OptionalScopes, len(in))
		copy(*out, in)
	} else {
		out.Scopes = nil
	}
	return nil
}

func DeepCopy_v1_NamedClusterRole(in NamedClusterRole, out *NamedClusterRole, c *conversion.Cloner) error {
	out.Name = in.Name
	if err := DeepCopy_v1_ClusterRole(in.Role, &out.Role, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_NamedClusterRoleBinding(in NamedClusterRoleBinding, out *NamedClusterRoleBinding, c *conversion.Cloner) error {
	out.Name = in.Name
	if err := DeepCopy_v1_ClusterRoleBinding(in.RoleBinding, &out.RoleBinding, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_NamedRole(in NamedRole, out *NamedRole, c *conversion.Cloner) error {
	out.Name = in.Name
	if err := DeepCopy_v1_Role(in.Role, &out.Role, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_NamedRoleBinding(in NamedRoleBinding, out *NamedRoleBinding, c *conversion.Cloner) error {
	out.Name = in.Name
	if err := DeepCopy_v1_RoleBinding(in.RoleBinding, &out.RoleBinding, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_Policy(in Policy, out *Policy, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_Time(in.LastModified, &out.LastModified, c); err != nil {
		return err
	}
	if in.Roles != nil {
		in, out := in.Roles, &out.Roles
		*out = make(NamedRoles, len(in))
		for i := range in {
			if err := DeepCopy_v1_NamedRole(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Roles = nil
	}
	return nil
}

func DeepCopy_v1_PolicyBinding(in PolicyBinding, out *PolicyBinding, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_Time(in.LastModified, &out.LastModified, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectReference(in.PolicyRef, &out.PolicyRef, c); err != nil {
		return err
	}
	if in.RoleBindings != nil {
		in, out := in.RoleBindings, &out.RoleBindings
		*out = make(NamedRoleBindings, len(in))
		for i := range in {
			if err := DeepCopy_v1_NamedRoleBinding(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.RoleBindings = nil
	}
	return nil
}

func DeepCopy_v1_PolicyBindingList(in PolicyBindingList, out *PolicyBindingList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]PolicyBinding, len(in))
		for i := range in {
			if err := DeepCopy_v1_PolicyBinding(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_PolicyList(in PolicyList, out *PolicyList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]Policy, len(in))
		for i := range in {
			if err := DeepCopy_v1_Policy(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_PolicyRule(in PolicyRule, out *PolicyRule, c *conversion.Cloner) error {
	if in.Verbs != nil {
		in, out := in.Verbs, &out.Verbs
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Verbs = nil
	}
	if err := runtime.DeepCopy_runtime_RawExtension(in.AttributeRestrictions, &out.AttributeRestrictions, c); err != nil {
		return err
	}
	if in.APIGroups != nil {
		in, out := in.APIGroups, &out.APIGroups
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.APIGroups = nil
	}
	if in.Resources != nil {
		in, out := in.Resources, &out.Resources
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Resources = nil
	}
	if in.ResourceNames != nil {
		in, out := in.ResourceNames, &out.ResourceNames
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.ResourceNames = nil
	}
	if in.NonResourceURLsSlice != nil {
		in, out := in.NonResourceURLsSlice, &out.NonResourceURLsSlice
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.NonResourceURLsSlice = nil
	}
	return nil
}

func DeepCopy_v1_ResourceAccessReview(in ResourceAccessReview, out *ResourceAccessReview, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1_Action(in.Action, &out.Action, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_ResourceAccessReviewResponse(in ResourceAccessReviewResponse, out *ResourceAccessReviewResponse, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	out.Namespace = in.Namespace
	if in.UsersSlice != nil {
		in, out := in.UsersSlice, &out.UsersSlice
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.UsersSlice = nil
	}
	if in.GroupsSlice != nil {
		in, out := in.GroupsSlice, &out.GroupsSlice
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.GroupsSlice = nil
	}
	out.EvaluationError = in.EvaluationError
	return nil
}

func DeepCopy_v1_Role(in Role, out *Role, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if in.Rules != nil {
		in, out := in.Rules, &out.Rules
		*out = make([]PolicyRule, len(in))
		for i := range in {
			if err := DeepCopy_v1_PolicyRule(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Rules = nil
	}
	return nil
}

func DeepCopy_v1_RoleBinding(in RoleBinding, out *RoleBinding, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	if in.UserNames != nil {
		in, out := in.UserNames, &out.UserNames
		*out = make(OptionalNames, len(in))
		copy(*out, in)
	} else {
		out.UserNames = nil
	}
	if in.GroupNames != nil {
		in, out := in.GroupNames, &out.GroupNames
		*out = make(OptionalNames, len(in))
		copy(*out, in)
	} else {
		out.GroupNames = nil
	}
	if in.Subjects != nil {
		in, out := in.Subjects, &out.Subjects
		*out = make([]api_v1.ObjectReference, len(in))
		for i := range in {
			if err := api_v1.DeepCopy_v1_ObjectReference(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Subjects = nil
	}
	if err := api_v1.DeepCopy_v1_ObjectReference(in.RoleRef, &out.RoleRef, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_RoleBindingList(in RoleBindingList, out *RoleBindingList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]RoleBinding, len(in))
		for i := range in {
			if err := DeepCopy_v1_RoleBinding(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_RoleList(in RoleList, out *RoleList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]Role, len(in))
		for i := range in {
			if err := DeepCopy_v1_Role(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_SelfSubjectRulesReview(in SelfSubjectRulesReview, out *SelfSubjectRulesReview, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1_SelfSubjectRulesReviewSpec(in.Spec, &out.Spec, c); err != nil {
		return err
	}
	if err := DeepCopy_v1_SubjectRulesReviewStatus(in.Status, &out.Status, c); err != nil {
		return err
	}
	return nil
}

func DeepCopy_v1_SelfSubjectRulesReviewSpec(in SelfSubjectRulesReviewSpec, out *SelfSubjectRulesReviewSpec, c *conversion.Cloner) error {
	if in.Scopes != nil {
		in, out := in.Scopes, &out.Scopes
		*out = make(OptionalScopes, len(in))
		copy(*out, in)
	} else {
		out.Scopes = nil
	}
	return nil
}

func DeepCopy_v1_SubjectAccessReview(in SubjectAccessReview, out *SubjectAccessReview, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := DeepCopy_v1_Action(in.Action, &out.Action, c); err != nil {
		return err
	}
	out.User = in.User
	if in.GroupsSlice != nil {
		in, out := in.GroupsSlice, &out.GroupsSlice
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.GroupsSlice = nil
	}
	if in.Scopes != nil {
		in, out := in.Scopes, &out.Scopes
		*out = make(OptionalScopes, len(in))
		copy(*out, in)
	} else {
		out.Scopes = nil
	}
	return nil
}

func DeepCopy_v1_SubjectAccessReviewResponse(in SubjectAccessReviewResponse, out *SubjectAccessReviewResponse, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	out.Namespace = in.Namespace
	out.Allowed = in.Allowed
	out.Reason = in.Reason
	out.EvaluationError = in.EvaluationError
	return nil
}

func DeepCopy_v1_SubjectRulesReviewStatus(in SubjectRulesReviewStatus, out *SubjectRulesReviewStatus, c *conversion.Cloner) error {
	if in.Rules != nil {
		in, out := in.Rules, &out.Rules
		*out = make([]PolicyRule, len(in))
		for i := range in {
			if err := DeepCopy_v1_PolicyRule(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Rules = nil
	}
	out.EvaluationError = in.EvaluationError
	return nil
}
