// +build !ignore_autogenerated_openshift

// This file was autogenerated by deepcopy-gen. Do not edit it manually!

package v1

import (
	api "k8s.io/kubernetes/pkg/api"
	unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	api_v1 "k8s.io/kubernetes/pkg/api/v1"
	conversion "k8s.io/kubernetes/pkg/conversion"
)

func init() {
	if err := api.Scheme.AddGeneratedDeepCopyFuncs(
		DeepCopy_v1_ClusterRoleScopeRestriction,
		DeepCopy_v1_OAuthAccessToken,
		DeepCopy_v1_OAuthAccessTokenList,
		DeepCopy_v1_OAuthAuthorizeToken,
		DeepCopy_v1_OAuthAuthorizeTokenList,
		DeepCopy_v1_OAuthClient,
		DeepCopy_v1_OAuthClientAuthorization,
		DeepCopy_v1_OAuthClientAuthorizationList,
		DeepCopy_v1_OAuthClientList,
		DeepCopy_v1_ScopeRestriction,
	); err != nil {
		// if one of the deep copy functions is malformed, detect it immediately.
		panic(err)
	}
}

func DeepCopy_v1_ClusterRoleScopeRestriction(in ClusterRoleScopeRestriction, out *ClusterRoleScopeRestriction, c *conversion.Cloner) error {
	if in.RoleNames != nil {
		in, out := in.RoleNames, &out.RoleNames
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.RoleNames = nil
	}
	if in.Namespaces != nil {
		in, out := in.Namespaces, &out.Namespaces
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Namespaces = nil
	}
	out.AllowEscalation = in.AllowEscalation
	return nil
}

func DeepCopy_v1_OAuthAccessToken(in OAuthAccessToken, out *OAuthAccessToken, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	out.ClientName = in.ClientName
	out.ExpiresIn = in.ExpiresIn
	if in.Scopes != nil {
		in, out := in.Scopes, &out.Scopes
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Scopes = nil
	}
	out.RedirectURI = in.RedirectURI
	out.UserName = in.UserName
	out.UserUID = in.UserUID
	out.AuthorizeToken = in.AuthorizeToken
	out.RefreshToken = in.RefreshToken
	return nil
}

func DeepCopy_v1_OAuthAccessTokenList(in OAuthAccessTokenList, out *OAuthAccessTokenList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]OAuthAccessToken, len(in))
		for i := range in {
			if err := DeepCopy_v1_OAuthAccessToken(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_OAuthAuthorizeToken(in OAuthAuthorizeToken, out *OAuthAuthorizeToken, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	out.ClientName = in.ClientName
	out.ExpiresIn = in.ExpiresIn
	if in.Scopes != nil {
		in, out := in.Scopes, &out.Scopes
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Scopes = nil
	}
	out.RedirectURI = in.RedirectURI
	out.State = in.State
	out.UserName = in.UserName
	out.UserUID = in.UserUID
	return nil
}

func DeepCopy_v1_OAuthAuthorizeTokenList(in OAuthAuthorizeTokenList, out *OAuthAuthorizeTokenList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]OAuthAuthorizeToken, len(in))
		for i := range in {
			if err := DeepCopy_v1_OAuthAuthorizeToken(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_OAuthClient(in OAuthClient, out *OAuthClient, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	out.Secret = in.Secret
	if in.AdditionalSecrets != nil {
		in, out := in.AdditionalSecrets, &out.AdditionalSecrets
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.AdditionalSecrets = nil
	}
	out.RespondWithChallenges = in.RespondWithChallenges
	if in.RedirectURIs != nil {
		in, out := in.RedirectURIs, &out.RedirectURIs
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.RedirectURIs = nil
	}
	out.GrantMethod = in.GrantMethod
	if in.ScopeRestrictions != nil {
		in, out := in.ScopeRestrictions, &out.ScopeRestrictions
		*out = make([]ScopeRestriction, len(in))
		for i := range in {
			if err := DeepCopy_v1_ScopeRestriction(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.ScopeRestrictions = nil
	}
	return nil
}

func DeepCopy_v1_OAuthClientAuthorization(in OAuthClientAuthorization, out *OAuthClientAuthorization, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := api_v1.DeepCopy_v1_ObjectMeta(in.ObjectMeta, &out.ObjectMeta, c); err != nil {
		return err
	}
	out.ClientName = in.ClientName
	out.UserName = in.UserName
	out.UserUID = in.UserUID
	if in.Scopes != nil {
		in, out := in.Scopes, &out.Scopes
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.Scopes = nil
	}
	return nil
}

func DeepCopy_v1_OAuthClientAuthorizationList(in OAuthClientAuthorizationList, out *OAuthClientAuthorizationList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]OAuthClientAuthorization, len(in))
		for i := range in {
			if err := DeepCopy_v1_OAuthClientAuthorization(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_OAuthClientList(in OAuthClientList, out *OAuthClientList, c *conversion.Cloner) error {
	if err := unversioned.DeepCopy_unversioned_TypeMeta(in.TypeMeta, &out.TypeMeta, c); err != nil {
		return err
	}
	if err := unversioned.DeepCopy_unversioned_ListMeta(in.ListMeta, &out.ListMeta, c); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := in.Items, &out.Items
		*out = make([]OAuthClient, len(in))
		for i := range in {
			if err := DeepCopy_v1_OAuthClient(in[i], &(*out)[i], c); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func DeepCopy_v1_ScopeRestriction(in ScopeRestriction, out *ScopeRestriction, c *conversion.Cloner) error {
	if in.ExactValues != nil {
		in, out := in.ExactValues, &out.ExactValues
		*out = make([]string, len(in))
		copy(*out, in)
	} else {
		out.ExactValues = nil
	}
	if in.ClusterRole != nil {
		in, out := in.ClusterRole, &out.ClusterRole
		*out = new(ClusterRoleScopeRestriction)
		if err := DeepCopy_v1_ClusterRoleScopeRestriction(*in, *out, c); err != nil {
			return err
		}
	} else {
		out.ClusterRole = nil
	}
	return nil
}
